<!DOCTYPE html>
<html>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head>
	<link rel="stylesheet" type="text/css" href="//lsub.org/ls/class.css" />
	<title>
		Clive User's Manual, 2nd ed.
	</title>
</head>
<body>
<div id="container" class="Container">

	<div id="header" class="Header">
		<a href="//lsub.org/ls/index.html">
		<img src="//lsub.org/ls/figs/lsub-peq.png" height="50px" width="50px"> 
		</a>
		<div style="position: absolute; top: 25px; left: 70px">
			Laboratorio de Sistemas // Systems Lab
		</div>
	</div>

	<div id="menu" class="Menu">
		<a class="MenuText" href="//lsub.org/ls/index.html">Welcome</a><br> 
		<a class="MenuText" href="//lsub.org/ls/research.html">Research &amp; innovation</a><br> 
		<a class="MenuText" href="//lsub.org/ls/training.html">Courses &amp; training</a><br> 
		<a class="MenuText" href="//lsub.org/ls/software.html">Software &amp; consulting</a><br> 
		<a class="MenuText" href="//lsub.org/ls/projects.html">Systems we made</a>
		<a class="MenuText" href="//lsub.org/ls/contact.html">Contact</a>
	</div>

	<div id="content" class="Content">
<b><a href="//lsub.org/sys/man">User's manual</a>.</b>
<b><a href="//lsub.org/sys/man/1">Section 1</a>.</b>
<h2>QL(1): clive shell</h2>
<hr>
<p>

<a name="sec1"></a><h2>USAGE</h2>
<p><ul style="list-style:none;">
    <code><pre>
    usage: ql [-DLNYcinux] [file] ...
        -D: debug
        -L: debug lex
        -N: debug nodes
        -Y: debug yacc
        -c: run args as a command
        -i: interactive
        -n: dry run
        -u: do not use unix IO
        -x: print commands as they are run
    </pre></code>
<p>
</ul><p>
<a name="sec2"></a><h2>DESCRIPTION</h2>
<em>Ql</em> is the Clive shell. In reads commands from
either the standard input or a file given in the command line and
executes them. Flag <code>-c</code> may be used to make
the arguments represent a command to be executed and not file names.
<p>
When executing a file, the entire file is read before processing its
contents. It is safe to edit or remove the file while it runs.
Arguments following the given file name are used as arguments for the
script file being executed. Under flag <code>-c</code> the
command is supplied in the argument list.
<p>
Text enclosed in single or reverse quotes, like
<code>&#39;...&#39;</code> and <code>`....`</code> is
taken verbatim as a single word.
<p>
The <code>#</code> character can be used to write line
comments. Empty lines are ignored. All other text is parsed as a
series of commands. Each command is executed only after its source
text has been fully parsed. For example, commands within a block are
not executed until the entire block is read from the input text and
parses correctly.
<p>
The prompt is &#34;<code>&gt; </code>&#34;. Any run of
&#34;<code>&gt;</code>&#34; characters (and blanks) at the start of
line are silently discarded, to help the user in selecting command
lines and executing them again.
<p>
Commands are one or more words (none for the empty command) terminated
either by a new-line character or using a
&#34;<code>;</code>&#34;. A backslash before a new-line converts
the new-line into a space, to type long commands in multiple lines.
After a pipe-line character, a new-line may be typed and it will be
ignored, for the same purpose.
<p>
Command words are separated by runs of white space, unless they result
from constructs (described later) which preserve words as generated by
other commands.
<p>
A command can be:
<ul>
    <li>A pipe line
    <li>A block of commands
    <li>A source command
    <li>A function definition, terminated with a new-line or a
    <code>;</code> character.
    <li>A <code>for</code> loop
    <li>A <code>while</code> loop
    <li>A <code>cond</code> (conditional) structure
    <li>An assignment.
</ul>
In all cases, optional redirections for input and output can follow.
An optional <code>&amp;</code> can be added at the end if
<em>ql</em> should not wait for the command to terminate
before prompting for another command. This is called a background
command. The <code>&amp;</code> operator can be followed by a
name to tag the command. The <code>wait</code> builtin
waits for background commands and can be given tags as arguments to
wait just for those commands. Without arguments,
<code>wait</code> waits for all outstanding background
commands.
<p>
A pipe-line is a series of simple commands separated by
&#34;<code></code>&#34; characters, perhaps a single one, or an
empty one. Here, the <em>in</em> channel of a command is
the <em>out</em> channel of the preceding one. The syntax
&#34;<code>|[err]</code>&#34;, (where <em>err</em> can
be any channel name) connects the <em>err</em> channel of
the preceding command to the <em>in</em> channel of the
following one. The syntax &#34;<code>|[x:y]</code>&#34; connects
the <em>y</em> channel of the preceding command to the
<em>x</em> channel of the following one. The general
syntax permits arbitrary networks of channels and has the form
&#34;<code>|[x:y,z;p:q,r...]</code>&#34;
<p>
The first name is a list of names used as a command is understood as
the command name. If it matches the name of a function, the function
is executed as a command. If it matches the name of a built-in, the
built-in is executed as a command. If the name starts with
&#34;<code>/</code>&#34;, &#34;<code>./</code>&#34;, or
&#34;<code>../</code>&#34;, it is uses as a relative path to the
file for the command. Otherwise, the name is appended to each of the
directories in <code>$path</code> (or
<code>$PATH</code> if the former is not defined) and the
first file found with execute permissions is run as a command. The
<code>type</code> builtin may be given one or more names
and prints the type of name (function, builtin, etc.).
<p>
When a command terminates, <code>$sts</code> contains the
exit status for the command, which is empty for success.
<p>
A block of commands is a series of commands encondes in
&#34;<code>{</code>&#34; and &#34;<code>}</code>&#34;
characters.
<p>
A source command has the form
<p><ul style="list-style:none;">
    <code><pre>
    &lt; file
    </pre></code>
</ul><p>
and executes the text in <code>file</code> as commands.
This can be used to include input for the shell from another file.
<p>
Functions may be defined line in
<p><ul style="list-style:none;">
    <code><pre>
    func name { cmds }
    </pre></code>
</ul><p>
Once defined, the function <em>name</em> may be used as a
command. Arguments supplied are available in
<code>$argv</code> within the function. The name of the
function is in <code>$argv0</code>. The status of the last
command in the function is used as the status of the function.
<p>
The <code>for</code> control structure has the form
<p><ul style="list-style:none;">
    <code><pre>
    for name val... { cmds }
    </pre></code>
</ul><p>
and sets <code>$name</code> to each one of the names that
follow and runs the body block for each value.
<p>
When using the form
<p><ul style="list-style:none;">
    <code><pre>
    for name { cmds }
    </pre></code>
</ul><p>
the loop iterates over the messages received from the standard input
and not over the names given in the command line.
<p>
The <code>while</code> control structure has the form
<p><ul style="list-style:none;">
    <code><pre>
    while cmd { cmds }
    </pre></code>
</ul><p>
and executes the body block while the command used as a condition
terminates with success.
<p>
The <code>cond</code> control structure is the only
conditional and has the form
<p><ul style="list-style:none;">
    <code><pre>
    cond {
        cmd1
        cmd2
        ...
        cmdn
    }
    </pre></code>
</ul><p>
With optional <em>or</em> branches added, like in:
<p><ul style="list-style:none;">
    <code><pre>
    cond {
        ...
    } or {
        ...
    } or {
        ...
    } ...
    </pre></code>
</ul><p>
Each one of the <em>or</em> branches (perhaps a single one
if no <em>or</em> is used) executes in order until one
succeeds. An <em>or</em> branch executes the commands in
its block in order until one fails or until the last command runs. If
the last command runs, the <em>or</em> branch succeeds. In
short, the conditional is an <em>or</em> for
<em>ands</em> of commands. You might think of all commands
in a block as the conditions for the last command in that block, which
might be considered as the body of a conventional
<em>if</em> construct.
<p>
<a name="sec2x1"></a><h3>VARIABLES</h3>
A name list (as used in a command) may include names starting with
&#34;<code>$</code>&#34; which are replaced by the values of the
conrresponding (environment) variables. Each variable is a list of
names, and the substitution preserves the name boundaries. Variable
values are never parsed as control structures and are expanded just
once, as part of a name list.
<p>
Within a name, the characters &#34;<code>=$</code>&#34; are not
special and are considered part of the name, but the
&#34;<code>=</code>&#34; character is still considered the
assignment operator within the first name of each line. This produces
the desired results in most cases and avoids the need to quote the
&#34;<code>=</code>&#34; character in predicates and command
arguments.
<p>
A variable may be assigned a value using
<p><ul style="list-style:none;">
    <code><pre>
    name=value
    </pre></code>
</ul><p>
or
<p><ul style="list-style:none;">
    <code><pre>
    var‚Üêname
    </pre></code>
</ul><p>
where <em>value</em> is, in general, a list of names. For
example:
<p><ul style="list-style:none;">
    <code><pre>
    name = (a b c)
    </pre></code>
</ul><p>
The syntax &#34;<code>$name</code>&#34; expands to the series of
names in the value of the variable. The number of elements is
retrieved using &#34;<code>$#name</code>&#34;. The syntax
&#34;<code>$^name</code>&#34; can be used to expand the value of
the variable to a single name (with words joined by single spaces).
Each element in the list can be retrieved using
&#34;<code>$name[0]</code>&#34;,
&#34;<code>$name[1]</code>&#34;, etc. The index can be a variable,
as in &#34;<code>$name[$idx]</code>&#34;, but using
&#34;<code>$$name</code>&#34; is a syntax error. The assignment
<p><ul style="list-style:none;">
    <code><pre>
    name[n]= value
    </pre></code>
</ul><p>
updates the value of that position in the variable. Even if
<em>value</em> is a list, the variable still retains the
same number of elements. One of the examples further illustrates this.
<p>
Variables can be also maps, defined as in
<p><ul style="list-style:none;">
    <code><pre>
    name=([key1 values...] [key2 values...] ...)
    </pre></code>
</ul><p>
The expression &#34;<code>$name</code>&#34; expands to the set of
keys for the map. The expression &#34;<code>$name[key]</code>&#34;
expands to the values for that key. See the example section.
<p>
Lists can be concatenated using the &#34;<code>^</code>&#34;
operator. If both arguments have the same number of elements, the
result is a list with the same number of elements and each one is the
concatenation of the same element in both lists. If one of the lists
has one element, that element is concatenated to each one of the
elements of the other argument. Otherwise, it is an error to try to
concatenate the lists. But you might use:
<p><ul style="list-style:none;">
    <code><pre>
    x=($y and other values)
    </pre></code>
<p>
</ul><p>
<code>
<p>
The </code>shift<code> builtin drops the first name in the
named variable, or in </code>argv<code> if no variable
name is given.
<p>
The following variables are pre-defined or used by the shell:
<dl>
    <dt></code>argv<code></dt><dd>
the argument list of
        scripts and functions
    </dd>
    <dt></code>argv0<code></dt><dd>
the name of the script
    </dd>
    <dt></code>sts<code></dt><dd>
the exit status of the
        last command. For blocks, the one of their last command
    </dd>
    <dt></code>path<code></dt><dd>
the preferred locations
        to search for external commands.
    </dd>
</dl>
The user may assign values to them.
<p>
Although not predefined, the </code>NS<code> variable
contains the textual representation of the name space, as shown in
[cite: intro(1)], when name spaces are used.
<p>
<a name="sec2x2"></a><h3>REDIRECTIONS</h3>
Optional edirections can be written at the end of commands. Note that
a &#34;</code>&lt;<code>&#34; at the start of a command line is a
source command and not a redirection.
<p>
To redirect standard input from a file, use
<p><ul style="list-style:none;">
    <code><pre>
    cmd... &lt; name
    </pre></code>
</ul><p>
or
<p><ul style="list-style:none;">
    <code><pre>
    cmd... &lt;[in] name
    </pre></code>
</ul><p>
The name in brackets indicates the channel that is to be defined as
the input channel from the named file. Here, _name_ is the name for a
file (tree), including both a path and a predicate, thus
<p><ul style="list-style:none;">
    <code><pre>
    cat &lt;,-
    </pre></code>
</ul><p>
would print the contents of all the regular files under the current
directory. In this example the name has an implicit
&#34;</code>.<code>&#34; as the path and a
&#34;</code>-<code>&#34;, which is actually
&#34;</code>type=-<code>&#34;, as the predicate; together it means
all the regular files under the current directory). All those files
are streamed through the _in_ channel for the command.
<p>
To redirect standard output to a file, use
<p><ul style="list-style:none;">
    <code><pre>
    &gt; file
    </pre></code>
</ul><p>
to create the output file (or truncate it). Or use
<p><ul style="list-style:none;">
    <code><pre>
    &gt;&gt; file
    </pre></code>
</ul><p>
to append to that file. In this case, for safety, no predicates are
accepted; only a file path.
<p>
Output channel names may be given after the redirection operator to
redirect output for those channels to the named file, as in:
<p><ul style="list-style:none;">
    <code><pre>
    cmd &gt;[err]/tmp/errors
    cmd &gt;[out,err]/tmp/outputanderrors
    </pre></code>
<p>
</ul><p>
The syntax
<p><ul style="list-style:none;">
    <code><pre>
    cmd &gt;[out:err]
    </pre></code>
</ul><p>
makes the _out_ channel be that used as the _err_ channel. It is a
_dup_, and channels are named in the same order used in the
assignment, as a remainder of which channel is the old one and which
one is the new one.
<p>
The syntax
<p><ul style="list-style:none;">
    <code><pre>
    cmd &lt;{cmd2...}
    </pre></code>
</ul><p>
Takes the output from _cmd2_ and interpolates it in the command line
at that place. This is command substitution. Each message printed by
_cmd2_ is used as a different word in the command line. There are
examples later, but these are usual usages:
<p><ul style="list-style:none;">
    <code><pre>
    cmd &lt;{cmd2... | lines}
    cmd &lt;{cmd2... | words}
    cmd &lt;{cmd2... | all}
    </pre></code>
<p>
</ul><p>
The syntax
<p><ul style="list-style:none;">
    <code><pre>
    cmd &lt;[in2]{cmd2...}
    </pre></code>
</ul><p>
creates the _in2_ channel for _cmd_ as an input channel that will
convey the output for the enclosed _cmd2_, and the whole construct is
replaced by the name of the channel. When Clive commands convert the
arguments to input channels, they notice that the name is for an input
channel and retrieve input from there. The general construct is
&#34;</code>&lt;[in:out1,out2...]{...}<code>&#34; to pipe arbitrary
channels.
<p>
The syntax
<p><ul style="list-style:none;">
    <code><pre>
    cmd &gt;[out2]{cmd2...}
    </pre></code>
</ul><p>
is similar, but it creates an output channel to _cmd2_ given as an
argument to _cmd_.
<p>
<a name="sec2x3"></a><h3>BUILT-IN COMMANDS</h3>
The following commands are built into </code>ql<code>:
<dl>
    <dt></code>cd [name]<code></dt><dd>
Change current
        directory to the given one or the home directory if none.
    </dd>
    <dt></code>pwd<code></dt><dd>
Print the working
        directory.
    </dd>
    <dt></code>exit [sts]<code></dt><dd>
Terminate the
        execution of </code>ql<code> using the given argument, if
        any, as the exit status.
    </dd>
    <dt></code>break<code></dt><dd>
Stop the enclosing
        construct (a </code>for<code>,
        </code>while<code>, or </code>cond<code>) and
        continue executing the next command.
    </dd>
    <dt></code>wait {tag}<code></dt><dd>
Wait for previous
        background commands to complete. If no tag is supplied, it waits for
        all of them. Otherwise, it waits for the pipeline with the given tag
        (an optional name written after the </code>&amp;<code> in the
        pipeline).
    </dd>
    <dt></code>type {name}<code></dt><dd>
inform of the
        type of object known as </code>name<code>. It may be a
        builtin, a function, an environment variable or the path used to
        execute it as a command.
    </dd>
    <dt></code>fork {resource}<code></dt><dd>
dups the
        resource, which can be </code>ns<code>,
        </code>io<code>, </code>dot<code>, or
        </code>env<code>.
    </dd>
    <dt></code>shift [var]<code></dt><dd>
Drop the first
        element of the given variable (</code>argv<code> by
        default).
<p>
    </dd>
</dl>
Most other Clive commands are usually linked into the same
</code>ql<code> binary, use </code>type<code>
to discover which ones are external and which ones are not.
<p>
<a name="sec3"></a><h2>EXAMPLES</h2>
Variables as lists:
<p><ul style="list-style:none;">
    <code><pre>
    &gt; x=(a b c)
    &gt; x[0]=(q w e)
    &gt; echo $x
    q w e b c
    &gt; echo $#x
    3
    &gt; echo $x[0]
    q w e
    &gt; x=&lt;{eco $x}
    &gt; echo $x
    q w e b c
    &gt; echo $#x
    1
    &gt; x=&lt;{eco $x|words}
    &gt; echo $#x
    5
    </pre></code>
</ul><p>
Concatenation:
<p><ul style="list-style:none;">
    <code><pre>
    &gt; x=(a b)
    &gt; echo $x^x
    ax bx
    &gt; y=($x c d)
    &gt; echo $y
    a b c d
    &gt; echo $#y
    4
    </pre></code>
</ul><p>
Variables as maps:
<p><ul style="list-style:none;">
    <code><pre>
    &gt; x=([a b] [x y z])
    &gt; echo $x
    a x
    &gt; y=$x[x]
    &gt; echo $y
    y z
    &gt; echo $#y
    2
    </pre></code>
<p>
</ul><p>
Command substitution:
<p><ul style="list-style:none;">
    <code><pre>
    &gt; for x &lt;{eco a ; eco b} {
    &gt; eco -u $x
    &gt; }
    a
    b
    &gt; for x &lt;{eco a b} {
    &gt; eco -u $x
    &gt; }
    a b
    </pre></code>
    Also,
    <code><pre>
    &gt; for line &lt;{lf -g ,- | lines} {
    &gt; do something to $line
    &gt; }
    </pre></code>
    which can be done also as:
    <code><pre>
    &gt; lf -g ,- | lines | for line {
    &gt; do something to $line
    &gt; }
    </pre></code>
<p>
    <code><pre>
    &gt; eco -u &lt;[in2]{eco a}
    |&lt;in2
    </pre></code>
    <code><pre>
    &gt; pf &lt;[in2]{eco a} &lt;[in3]{eco b c}
    c ---------      0 |&lt;in2
    a
    c ---------      0 |&lt;in3
    b c
    </pre></code>
<p>
</ul><p>
Predicates and redirections:
<p><ul style="list-style:none;">
    Issue an error to standard error:
    <code><pre>
    eco errors &gt;[out:err]
    </pre></code>
<p>
    Show all Go sources under the current directory
    <code><pre>
    pf &lt;,~*.go
    </pre></code>
    Or
    <code><pre>
    lf -g .,name~*.go | pf
    </pre></code>
    List all regular files under the current directory:
    <code><pre>
    lf -u ,-
    </pre></code>
<p>
    Long-list them:
    <code><pre>
    lf -u ,- |pf -l
    </pre></code>
<p>
    Grep them for </code>foo<code>:
    <code><pre>
    gr -u foo &lt;,-
    </pre></code>
<p>
    Define a long-list function:
    <code><pre>
    func ll {
        lf $argv | pf -l
    }
    </pre></code>
<p>
</ul><p>
<a name="sec4"></a><h2>SOURCE</h2>
<ul>
    <li></code>/zx/sys/src/clive/cmd/ql<code>
<p>
</ul>
<a name="sec5"></a><h2>SEE ALSO</h2>
<ul>
    <li></code>/zx/sys/src/clive/cmd/ql/example<code>
    contains examples for all the syntax understood by the shell.
<p>
</ul>
<p>
<hr><p>

<b><a href="//lsub.org/sys/man">User's manual</a>.</b>
<b><a href="//lsub.org/sys/man/1">Section 1</a>.</b>

	</div>
</div>

<div id="footer" class="Footer">
	Copyright ¬© LSUB 2014-2016
	<br><br>
	<a href="https://twitter.com/lsub_org"><img src="//lsub.org/ls/figs/twitter.png" height="25px" width="25px"> </a>
</div>

</body>
</html>

